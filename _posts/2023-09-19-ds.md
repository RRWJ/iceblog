---
layout: post
title: distribute system
date: 2023-09-19
tags: [Spring]
comments: false
---
一、背景
Kubernetes：
早期是以作为微服务的分布式部署运行系统为主，整体来说，Kubernetes的大概流程如下：
部署一个微服务的时候，设定微服务“目标”状态之后（内存/CPU/POD实例数）Scheduler分配POD作为一个运行部署单元，Controllers时刻监控各种POD的“实际”状态，一旦状态不符合，则将微服务恢复到目标状态。
这是一种常见的模式，通过设定目标状态（Target State），感知(Monitor)当前状态(Current State)，一旦当前状态和目标状态不符， Controller调节系统以使系统达到该状态。
目前使用的很多中间件，当目标状态和当前状态不符（系统监控异常，系统需要补丁，系统需要备份），实际上是通过人力（SRE或者业务团队)把系统从当前状态调节到目标状态。

原生的Kubernetes对无状态的微服务实现了完善的控制器（Controller），由于微服务无状态，所以Kubernetes可以统一不同微服务的安装，升级，扩容，故障处理等等。
但是由于中间件有状态，原生的Kubernetes控制器难于完成中间件的控制，所以Kubernetes提供了一种扩展机制: Operator。
Operator允许定义各种自定义资源（Custom Resources）和自定义控制面程序，从而对这些自定义资源完成客户化的控制。
目前各个公司和社区纷纷利用该技术将各种中间件基于Kubernetes容器化技术 服务化。
MAS架构下，也是将各种中间件定义为资源，然后通过控制器实现对各种中间件的安装部署，升级，故障自愈，扩容等。
从生态来看，Kubernetes的社区发展快、生态更加活跃，自身具有灵活、强大的弹性资源调度/编排能力。

二、Grid服务化
一方面，分布式系统通常采用冗余、基于负载均衡的scale-out方式，来保证系统的可用性和可扩展性。冗余的常见的方式如主备，双活，多活等方式，负载均衡常用方式如4层负载均衡，7层负载均衡。
另一方面，在大规模分布式系统里，故障一直都在发生。一种常见的减少爆炸半径的方式是基于AZ和Region的划分，它基于“物理区域"维度来减小爆炸半径，AZ内故障不会波及到其他AZ和Region，
Region内故障不会波及到其他Region和其内的AZ。但是这种方式划分故障半径的最小的粒度为AZ，同时也不支持从业务维度（如按租户）来划分爆炸半径。因此，我们需要一种即能支持更细粒度的爆炸半径划分维度，同时又能支持从业务角度来划分爆炸半径的维度。
Grid架构是将系统划分为多个功能相同的业务单元，每个Grid单元具备完整业务功能，同时构建一层薄的路由层，将业务请求按设定规则路由到固定的Grid处理，如按用户分配到固定的Grid处理，任何一个Grid故障仅影响路由到该Grid的用户，不影响其他用户。
同时基于Grid划分，可以增强系统的可扩展性。不同于传统的扩展模型，基于Grid架构的系统以Grid为单位进行扩容。
服务化GridRouter/Etcd 当前部署在管理区，仅限管理区服务使用

Grid/Etcd处于管理区M1层，但位于M0的kkei物理机上
MAS(Middleware As Service)的管理平台负责gridrouter/etcd自身的发放、扩散容、升级等运维操作，主要应用k8s的面向终态调谐机制。
管理面的中间件能力归一，统一以服务化的方式，为业务系统提供高可用的、高性能的、可扩展的、经济的中间件能力。 

管理面：
前端Console界面下发发放实例、扩缩容、升级指令，由后台API Service将请求转发给K8S Api server，进而转发给GridRouter/Etcd Operator处理相应的请求；

数据面（用户未对接网格）：
服务请求经过APIG下发，根据域名解析可以得到LVS对外的vip，将请求发送至LVS，LVS的vip映射到GridRouter的pod ip，LVS将请求再转发至GridRouter pod上，
GridRouter根据用户的域名，可以得知路由策略，并查到对应的路由信息，进而得知deck域名，将请求转发至deck。

数据面（用户对接网格）：
服务请求经过APIG下发，根据域名解析可以得到lvs对外的vip，将请求发送至LVS，LVS的vip映射到GridRouter的pod ip，LVS将请求再转发至GridRouter pod上，
GridRouter根据用户的域名，可以得知路由策略，并查到对应的路由信息，进而得知deck域名，GSLB域名解析得出LVS对外的vip，将请求下发给LVS，LVS转发至网格的Ingress，Ingress再进一步转发到目标deck。

三、Etcd服务化
业界实现阿里云Etcd服务化方案：https://segmentfault.com/a/1190000039820855

四、核心开发
1、编排框架 -- 状态机
Spring Statemachine：https://github.com/spring-projects/spring-statemachine
Squirrel Statemachine：https://github.com/hekailiang/squirrel
COLA Statemachine：https://github.com/alibaba/COLA/tree/master/cola-components/cola-component-statemachine

2、分布式锁 -- 基于开源框架shedlock
3、K8S统一建连能力&CRD的统一读写能力
  a.K8S统一建连能力，CRD SPEC和K8S自身的配置解耦。
  b.CRD的统一读写能力，根据CRD元数据文件建模生成Java类。
  c.基于CRD模型类封装业务方法，业务只需要指定特定参数即可。

五、业务实现
1、Etcd滚动升级/GridRouter蓝绿升级
Gr蓝绿升级（Green-Blue Deployment）是一种在无缝切换的方式下，对应用程序或服务进行升级或回滚的方法。它允许在进行升级或回滚时保持应用程序的正常运行，以提供更好的用户体验。
以下是Gr蓝绿升级的步骤：
准备并部署与当前应用程序完全相同的新版本，作为"Green"环境。这个环境可以是一个新的服务器集群、容器集群或任何其他能够承载应用程序的环境。
配置负载均衡器（如Nginx、HAProxy等）以在"Green"环境上实现分发流量的功能。可以使用类似轮询、IP hash或权重等算法来控制流量的分发。
将一部分或全部流量引导到"Green"环境，同时保留一部分流量继续发送到当前的"Blue"环境。
监控"Green"环境的性能和稳定性。如果发现问题，可以回滚到"Blue"环境。
如果"Green"环境表现良好，可以逐渐增加发送给"Green"环境的流量比例，同时减少"Blue"环境的流量比例，直到完全切换到"Green"环境。
最后，关闭或卸载"Blue"环境并完成升级。
使用Gr蓝绿升级的好处在于在升级过程中最小化了应用程序的停机时间，同时提供了回退到之前稳定版本的能力。这种方法也可以减少用户感知到的服务中断，提供更好的用户体验。

Etcd的滚动升级是指在不停止服务的情况下，对Etcd集群进行升级。
滚动升级的步骤如下：
首先，准备一个新的Etcd版本，并确保它与当前运行的版本兼容。在Etcd集群中的每个节点上执行以下步骤：
a. 停止当前版本的Etcd进程，但保留数据存储。
b. 替换当前版本的Etcd二进制文件为新的版本。
c. 使用新的版本启动Etcd进程。确保配置文件和命令行参数与之前的版本相同。
在每个节点完成升级后，等待Etcd集群中的所有成员重新加入。
确认集群中的所有成员都成功加入，并且Etcd集群的状态正常。
重复上述步骤，直到所有节点都完成升级。
需要注意的是，在进行滚动升级时，应该进行适当的备份，并确保可以恢复到之前的状态。
此外，滚动升级可能导致一些服务中断或性能下降的问题，因此建议在非高峰期进行升级，以最小化对业务的影响。

2、Etcd/GridRouter扩缩容
创建对中间件集群的扩缩容的任务。任务是为集群设置的期望节点数量。
如果是扩容，则涉及到新节点的创建和引流；如果是缩容，则涉及到已有节点流量的摘除和副本销毁。

Gr扩缩容是指通过增加或减少GridRouter实例的数量来调整集群的规模。
Gr扩缩容的一般步骤如下：
创建新的GridRouter实例：当需要扩容时，首先创建一个或多个新的GridRouter实例。每个GridRouter实例负责处理集群中一部分客户端的请求。
迁移客户端连接：将现有客户端的连接逐步迁移到新的GridRouter实例上。这可以通过在应用程序中更新连接配置来实现。
验证和测试：在迁移完成后，需要进行验证和测试，确保新的GridRouter实例能够正常工作并提供所需的性能。
关闭旧的GridRouter实例：在验证和测试通过后，可以安全地关闭旧的GridRouter实例。这将减少集群中的GridRouter数量，并相应地降低资源使用。

当需要对Etcd集群进行扩缩容时，可以按照以下步骤进行操作：
添加新节点：准备好新的Etcd节点，并确保节点能够与已有集群中的节点进行网络通信。可以通过安装Etcd二进制文件或使用容器方式来部署新节点。
配置新节点：编辑新节点的Etcd配置文件，设置与已有节点相同的集群名称和共享的数据目录。确保新节点的监听地址、Peers列表以及其他配置项与已有节点一致。
启动新节点：使用Etcd二进制文件启动新节点，或者使用容器方式启动。新节点启动后，会尝试加入现有的Etcd集群。
监控新节点：使用Etcd监控工具（如Etcdctl、Etcd Browser等）监视新节点的状态，确保其能够成功加入集群。可以查看新节点的日志输出，查找任何错误或警告信息。
数据迁移：如果需要将现有数据平均分布到新节点上，可以使用Etcd工具（如Etcdctl snapshot命令）对现有集群中的数据进行备份，并将备份还原到新节点上。
重平衡集群：在新节点成功加入集群后，需要进行集群重平衡操作，以确保数据在各个节点上的均衡分布。可以使用Etcdctl工具执行健康检查和自动重平衡等操作。
测试和验证：在完成扩缩容操作后，进行一系列的测试和验证，确保新节点正常运行，并且集群的性能和可用性没有受到影响。
需要注意的是，在扩缩容过程中，最好做好备份，并进行合理的规划和测试，以确保数据的安全性和集群的稳定性。
对于滚动升级类型，查询的任务列表状态不是最新的。后续通过状态机/定时任务/实时查询等方式补偿

2、Etcd镜像（手动同步、自动同步）
在不同的AZ部署两套Etcd集群，在Etcd集群失败的时候，迅速切换到备Etcd集群继续服务。在主备集群之间，由于备集群被切换上去以后，需要继续服务用户(读写)，因此备集群在没有服务的时候，就需要从主集群同步数据。
底层实现：基于状态机编排逻辑，控制创建流程

3、Etcd备份（主动备份、自动备份）
目的：
a、为了保障 Etcd 数据的安全性和可靠性。
在分布式系统中，Etcd 存储着关键数据，如果出现数据损坏或丢失可能会导致系统出现故障甚至崩溃。为此，进行自动备份是非常必要的。通过定期执行自动备份任务，可以将 Etcd 中的数据备份下来，以便在发生故障或者意外情况时能够迅速恢复数据。
b、自动备份也是保证数据一致性的重要手段。Etcd采用Raft一致性算法保证数据的一致性，但在某些情况下，可能会出现节点故障或者网络不稳定等异常情况，从而导致数据不一致。如果备份及时，则可以通过备份数据来还原 Etcd 中的准确数据。
Etcd 自动备份可以实现以下功能：
在指定时间段执行备份任务：可以使用定时任务框架来配置定时备份，比如每日凌晨执行一次备份任务；
配置备份文件存储：当前统一采用桶存储，桶名由运维人员在console创建，备份文件存储在桶指定的目录中（空间不足，数据丢失）；
自动删除历史备份：可以根据备份文件的新旧来自动删除旧备份文件，避免备份数据占用过多的空间；
监控备份执行情况：自动备份过程中可能会出现错误，比如备份失败等问题，需要设置相应的监控机制来监控备份操作的执行情况；
底层实现：
自动创建和自动删除均由定时任务触发，由分布式锁保证任务插入的并发性
提供批处理机制

4、巡检异常主备切换
实施Etcd巡检是为了确保Etcd集群的正常运行和数据的一致性。在巡检过程中，发现异常时需要进行主备切换，以保证集群的稳定性。
当发现Etcd集群中的主节点出现异常时，可以通过以下步骤进行主备切换：
确认主节点的异常：可以通过Etcd的监控工具或命令行工具查看主节点的状态是否异常，例如使用etcdctl命令行工具执行etcdctl endpoint status命令。
确认备节点的状态：通过Etcd的监控工具或命令行工具查看备节点的状态是否正常。如果备节点也异常，则需要根据具体情况进行故障排查或修复。
执行主备切换：如果备节点状态正常，可以执行主备切换操作。主备切换的方法可以是使用Etcd提供的API或命令行工具，或者使用自动化脚本实现。在实施主备切换之前，需要确保备节点的数据与主节点的数据保持一致性，可以使用快照备份和恢复方法来完成数据的同步。
验证主备切换：主备切换完成后，需要验证新的主节点是否正常运行。可以使用Etcd的监控工具或命令行工具来确认新主节点的状态是否正常。
通过以上步骤进行Etcd巡检异常主备切换可以有效地保证Etcd集群的稳定性和数据的一致性。
具体实现：定时任务、自定义线程池

5、自动恢复
状态机

项目技术背景： 
kubernetes容器编排，api得功能是对k8s api-server得更进一层得封装(我目前理解是这样的)，以及相关依赖得三方模块控制，以达到对底层资源得控制分配，cr、opt、secret等；
这里可以简述k8s能力背景(直接参考官方文档)

operator：为什么我们要有operator，我们得operator得目的是为了什么，和api之间的交互能力； gr/etcd可以简述下能力（比如之前不是api和etcd对接备份和镜像那边，可以整理下）

api本身能力： 比如部署模式， 是否支持容灾，对于请求量得分布如何平均得（需要简单描述下，只说概念性的东西[比如：使用一致性哈希]太笼统了， 需要简单了解下），而且你的重点应该是api，所以偏向api这边的东西可以深挖一些，opt那边大致了解下交互其实就可以，不需要深入得东西
