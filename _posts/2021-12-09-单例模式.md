---
layout: post
title: 单例模式
subtitle: singleton
date: 2021-12-09 13:48:00 +0800
tags: [设计模式]
comments: false
---
```
// Lazy initialization：采用static变量修饰，全局单例对象在类加载时就被初始化
public class Singleton {
    public static Singleton instance;
    private Singleton(){
        System.out.println("线程："+Thread.currentThread().getName()+"初始化");
    }
    public static Singleton getInstance(){
        if (instance == null){
            instance = new Singleton(); //*注意此处*
        }
        return instance;
    }
}
```
> #### *注意此处* 
> instance = new Singleton(); 包含三个过程：
>
> 1.分配对象的存储空间；
>
> 2.初始化对象；
>
> 3.将instance指向新分配的内存地址；
>
> *在编译器或处理器指令重排序过程中会发生2.3步骤颠倒*。即：
>
> 1.分配对象的存储空间；
>
> 3.将instance指向新分配的内存地址；但此处对象还未被初始化
>
> 2.初始化对象；

### *当多线程并发执行时，会创建多个对象。*
```
public static void main(String[] args) {
        for (int i = 1; i<= 2; i++){
            Thread td = new Thread(new Runnable() {
                @Override
                public void run() {
                    Singleton.getInstance();
                }
            });
            td.start();
        }
    }
```
```
线程：Thread-1初始化
线程：Thread-0初始化
```
### 两种方法实现线程安全的延迟初始化
### *双重检查锁 double-checked locking*
#### 1. 基于volatile的解决方案：禁止2，3重排序
```
public volatile static safeDoubleCheckedLocking instance;
    private safeDoubleCheckedLocking(){
        System.out.println("线程："+Thread.currentThread().getName()+"初始化");
    }
    public static safeDoubleCheckedLocking getInstance(){
        if (instance == null){  // 第一次检查
            synchronized (safeDoubleCheckedLocking.class){ //加锁
                if (instance == null){ // 第二次检查
                    instance = new safeDoubleCheckedLocking();
                }
            }
        }
        return instance;
    }
}
```
```
线程：Thread-0初始化
```
### *initialization-on-demand holder idiom*
#### 2. 基于类初始化的解决方案：允许2，3重排序，但是对其他线程不可见
```
public class lazyFactory {
    private static class lazyHolder{
        static final lazyFactory instance = new lazyFactory();
    }
    private lazyFactory(){
        System.out.println("线程："+Thread.currentThread().getName()+"初始化");
    }
    public static lazyFactory getInstance(){
        return lazyHolder.instance;
    }
}
```
```
线程：Thread-8初始化
```
